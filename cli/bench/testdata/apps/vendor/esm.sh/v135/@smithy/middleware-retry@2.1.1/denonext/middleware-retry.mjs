/* esm.sh - esbuild bundle(@smithy/middleware-retry@2.1.1) denonext production */
import{DefaultRateLimiter as j,RETRY_MODES as z}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";import{HttpRequest as _,HttpResponse as Y}from"/v135/@smithy/protocol-http@3.1.1/denonext/protocol-http.mjs";import{isThrottlingError as v}from"/v135/@smithy/service-error-classification@2.1.1/denonext/service-error-classification.mjs";import{DEFAULT_MAX_ATTEMPTS as P,DEFAULT_RETRY_DELAY_BASE as L,INITIAL_RETRY_TOKENS as q,INVOCATION_ID_HEADER as F,REQUEST_HEADER as V,RETRY_MODES as Q,THROTTLING_RETRY_DELAY_BASE as U}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";import{v4 as X}from"/v135/uuid@8.3.2/denonext/uuid.mjs";import{NO_RETRY_INCREMENT as I,RETRY_COST as O,TIMEOUT_RETRY_COST as x}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";var T=(e,t)=>{let r=e,o=t?.noRetryIncrement??I,a=t?.retryCost??O,i=t?.timeoutRetryCost??x,s=e,c=m=>m.name==="TimeoutError"?i:a,y=m=>c(m)<=s;return Object.freeze({hasRetryTokens:y,retrieveRetryTokens:m=>{if(!y(m))throw new Error("No retry token available");let d=c(m);return s-=d,d},releaseRetryTokens:m=>{s+=m??o,s=Math.min(s,r)}})};import{MAXIMUM_RETRY_DELAY as b}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";var A=(e,t)=>Math.floor(Math.min(b,Math.random()*2**t*e));import{isClockSkewError as C,isRetryableByTrait as H,isThrottlingError as k,isTransientError as $}from"/v135/@smithy/service-error-classification@2.1.1/denonext/service-error-classification.mjs";var D=e=>e?H(e)||C(e)||k(e)||$(e):!1;var l=e=>e instanceof Error?e:e instanceof Object?Object.assign(new Error,e):typeof e=="string"?new Error(e):new Error(`AWS SDK error wrapper for ${e}`);var E=class{constructor(t,r){this.maxAttemptsProvider=t,this.mode=Q.STANDARD,this.retryDecider=r?.retryDecider??D,this.delayDecider=r?.delayDecider??A,this.retryQuota=r?.retryQuota??T(q)}shouldRetry(t,r,o){return r<o&&this.retryDecider(t)&&this.retryQuota.hasRetryTokens(t)}async getMaxAttempts(){let t;try{t=await this.maxAttemptsProvider()}catch{t=P}return t}async retry(t,r,o){let a,i=0,s=0,c=await this.getMaxAttempts(),{request:y}=r;for(_.isInstance(y)&&(y.headers[F]=X());;)try{_.isInstance(y)&&(y.headers[V]=`attempt=${i+1}; max=${c}`),o?.beforeRequest&&await o.beforeRequest();let{response:f,output:n}=await t(r);return o?.afterRequest&&o.afterRequest(f),this.retryQuota.releaseRetryTokens(a),n.$metadata.attempts=i+1,n.$metadata.totalRetryDelay=s,{response:f,output:n}}catch(f){let n=l(f);if(i++,this.shouldRetry(n,i,c)){a=this.retryQuota.retrieveRetryTokens(n);let m=this.delayDecider(v(n)?U:L,i),d=G(n.$response),R=Math.max(d||0,m);s+=R,await new Promise(u=>setTimeout(u,R));continue}throw n.$metadata||(n.$metadata={}),n.$metadata.attempts=i,n.$metadata.totalRetryDelay=s,n}}},G=e=>{if(!Y.isInstance(e))return;let t=Object.keys(e.headers).find(i=>i.toLowerCase()==="retry-after");if(!t)return;let r=e.headers[t],o=Number(r);return Number.isNaN(o)?new Date(r).getTime()-Date.now():o*1e3};var h=class extends E{constructor(t,r){let{rateLimiter:o,...a}=r??{};super(t,a),this.rateLimiter=o??new j,this.mode=z.ADAPTIVE}async retry(t,r){return super.retry(t,r,{beforeRequest:async()=>this.rateLimiter.getSendToken(),afterRequest:o=>{this.rateLimiter.updateClientSendingRate(o)}})}};import{normalizeProvider as S}from"/v135/@smithy/util-middleware@2.1.1/denonext/util-middleware.mjs";import{AdaptiveRetryStrategy as B,DEFAULT_MAX_ATTEMPTS as N,DEFAULT_RETRY_MODE as W,RETRY_MODES as K,StandardRetryStrategy as J}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";var w="AWS_MAX_ATTEMPTS",M="max_attempts",Ve={environmentVariableSelector:e=>{let t=e[w];if(!t)return;let r=parseInt(t);if(Number.isNaN(r))throw new Error(`Environment variable ${w} mast be a number, got "${t}"`);return r},configFileSelector:e=>{let t=e[M];if(!t)return;let r=parseInt(t);if(Number.isNaN(r))throw new Error(`Shared config file entry ${M} mast be a number, got "${t}"`);return r},default:N},Qe=e=>{let{retryStrategy:t}=e,r=S(e.maxAttempts??N);return{...e,maxAttempts:r,retryStrategy:async()=>t||(await S(e.retryMode)()===K.ADAPTIVE?new B(r):new J(r))}},Z="AWS_RETRY_MODE",ee="retry_mode",Ue={environmentVariableSelector:e=>e[Z],configFileSelector:e=>e[ee],default:W};import{HttpRequest as te}from"/v135/@smithy/protocol-http@3.1.1/denonext/protocol-http.mjs";import{INVOCATION_ID_HEADER as re,REQUEST_HEADER as oe}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";var ae=()=>e=>async t=>{let{request:r}=t;return te.isInstance(r)&&(delete r.headers[re],delete r.headers[oe]),e(t)},ne={name:"omitRetryHeadersMiddleware",tags:["RETRY","HEADERS","OMIT_RETRY_HEADERS"],relation:"before",toMiddleware:"awsAuthMiddleware",override:!0},ze=e=>({applyToStack:t=>{t.addRelativeTo(ae(),ne)}});import{HttpRequest as se,HttpResponse as ie}from"/v135/@smithy/protocol-http@3.1.1/denonext/protocol-http.mjs";import{isServerError as me,isThrottlingError as ce,isTransientError as ye}from"/v135/@smithy/service-error-classification@2.1.1/denonext/service-error-classification.mjs";import{NoOpLogger as fe}from"/v135/@smithy/smithy-client@2.3.1/denonext/smithy-client.mjs";import{INVOCATION_ID_HEADER as de,REQUEST_HEADER as Re}from"/v135/@smithy/util-retry@2.1.1/denonext/util-retry.mjs";import{v4 as ue}from"/v135/uuid@8.3.2/denonext/uuid.mjs";var g=e=>e?.body instanceof ReadableStream;var le=e=>(t,r)=>async o=>{let a=await e.retryStrategy(),i=await e.maxAttempts();if(Ee(a)){a=a;let s=await a.acquireInitialRetryToken(r.partition_id),c=new Error,y=0,f=0,{request:n}=o,m=se.isInstance(n);for(m&&(n.headers[de]=ue());;)try{m&&(n.headers[Re]=`attempt=${y+1}; max=${i}`);let{response:d,output:R}=await t(o);return a.recordSuccess(s),R.$metadata.attempts=y+1,R.$metadata.totalRetryDelay=f,{response:d,output:R}}catch(d){let R=pe(d);if(c=l(d),m&&g(n))throw(r.logger instanceof fe?console:r.logger)?.warn("An error was encountered in a non-retryable streaming request."),c;try{s=await a.refreshRetryTokenForRetry(s,R)}catch{throw c.$metadata||(c.$metadata={}),c.$metadata.attempts=y+1,c.$metadata.totalRetryDelay=f,c}y=s.getRetryCount();let u=s.getRetryDelay();f+=u,await new Promise(p=>setTimeout(p,u))}}else return a=a,a?.mode&&(r.userAgent=[...r.userAgent||[],["cfg/retry-mode",a.mode]]),a.retry(t,o)},Ee=e=>typeof e.acquireInitialRetryToken<"u"&&typeof e.refreshRetryTokenForRetry<"u"&&typeof e.recordSuccess<"u",pe=e=>{let t={errorType:Te(e)},r=De(e.$response);return r&&(t.retryAfterHint=r),t},Te=e=>ce(e)?"THROTTLING":ye(e)?"TRANSIENT":me(e)?"SERVER_ERROR":"CLIENT_ERROR",Ae={name:"retryMiddleware",tags:["RETRY"],step:"finalizeRequest",priority:"high",override:!0},at=e=>({applyToStack:t=>{t.add(le(e),Ae)}}),De=e=>{if(!ie.isInstance(e))return;let t=Object.keys(e.headers).find(i=>i.toLowerCase()==="retry-after");if(!t)return;let r=e.headers[t],o=Number(r);return Number.isNaN(o)?new Date(r):new Date(o*1e3)};export{h as AdaptiveRetryStrategy,M as CONFIG_MAX_ATTEMPTS,ee as CONFIG_RETRY_MODE,w as ENV_MAX_ATTEMPTS,Z as ENV_RETRY_MODE,Ve as NODE_MAX_ATTEMPT_CONFIG_OPTIONS,Ue as NODE_RETRY_MODE_CONFIG_OPTIONS,E as StandardRetryStrategy,A as defaultDelayDecider,D as defaultRetryDecider,ze as getOmitRetryHeadersPlugin,De as getRetryAfterHint,at as getRetryPlugin,ae as omitRetryHeadersMiddleware,ne as omitRetryHeadersMiddlewareOptions,Qe as resolveRetryConfig,le as retryMiddleware,Ae as retryMiddlewareOptions};
//# sourceMappingURL=middleware-retry.mjs.map