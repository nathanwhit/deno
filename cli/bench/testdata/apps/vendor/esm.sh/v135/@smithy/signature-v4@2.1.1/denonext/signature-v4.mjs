/* esm.sh - esbuild bundle(@smithy/signature-v4@2.1.1) denonext production */
import{HeaderMarshaller as de}from"/v135/@smithy/eventstream-codec@2.1.1/denonext/eventstream-codec.mjs";import{toHex as x}from"/v135/@smithy/util-hex-encoding@2.1.1/denonext/util-hex-encoding.mjs";import{normalizeProvider as re}from"/v135/@smithy/util-middleware@2.1.1/denonext/util-middleware.mjs";import{fromUtf8 as fe,toUint8Array as v,toUtf8 as ue}from"/v135/@smithy/util-utf8@2.1.1/denonext/util-utf8.mjs";var Y="X-Amz-Algorithm",b="X-Amz-Credential",I="X-Amz-Date",k="X-Amz-SignedHeaders",G="X-Amz-Expires",P="X-Amz-Signature",N="X-Amz-Security-Token";var C="authorization",$=I.toLowerCase(),ne="date",j=[C,$,ne],Q=P.toLowerCase(),l="x-amz-content-sha256",K=N.toLowerCase();var z={authorization:!0,"cache-control":!0,connection:!0,expect:!0,from:!0,"keep-alive":!0,"max-forwards":!0,pragma:!0,referer:!0,te:!0,trailer:!0,"transfer-encoding":!0,upgrade:!0,"user-agent":!0,"x-amzn-trace-id":!0},X=/^proxy-/,q=/^sec-/;var g="AWS4-HMAC-SHA256";var F="AWS4-HMAC-SHA256-PAYLOAD",W="UNSIGNED-PAYLOAD",Z=50,L="aws4_request",B=60*60*24*7;import{toHex as ae}from"/v135/@smithy/util-hex-encoding@2.1.1/denonext/util-hex-encoding.mjs";import{toUint8Array as ie}from"/v135/@smithy/util-utf8@2.1.1/denonext/util-utf8.mjs";var R={},_=[],y=(o,e,t)=>`${o}/${e}/${t}/${L}`,J=async(o,e,t,r,s)=>{let n=await V(o,e.secretAccessKey,e.accessKeyId),a=`${t}:${r}:${s}:${ae(n)}:${e.sessionToken}`;if(a in R)return R[a];for(_.push(a);_.length>Z;)delete R[_.shift()];let i=`AWS4${e.secretAccessKey}`;for(let A of[t,r,s,L])i=await V(o,i,A);return R[a]=i},_e=()=>{_.length=0,Object.keys(R).forEach(o=>{delete R[o]})},V=(o,e,t)=>{let r=new o(e);return r.update(ie(t)),r.digest()};var D=({headers:o},e,t)=>{let r={};for(let s of Object.keys(o).sort()){if(o[s]==null)continue;let n=s.toLowerCase();(n in z||e?.has(n)||X.test(n)||q.test(n))&&(!t||t&&!t.has(n))||(r[n]=o[s].trim().replace(/\s+/g," "))}return r};import{escapeUri as S}from"/v135/@smithy/util-uri-escape@2.1.1/denonext/util-uri-escape.mjs";var M=({query:o={}})=>{let e=[],t={};for(let r of Object.keys(o).sort()){if(r.toLowerCase()===Q)continue;e.push(r);let s=o[r];typeof s=="string"?t[r]=`${S(r)}=${S(s)}`:Array.isArray(s)&&(t[r]=s.slice(0).reduce((n,a)=>n.concat([`${S(r)}=${S(a)}`]),[]).sort().join("&"))}return e.map(r=>t[r]).filter(r=>r).join("&")};import{isArrayBuffer as ce}from"/v135/@smithy/is-array-buffer@2.1.1/denonext/is-array-buffer.mjs";import{toHex as Ee}from"/v135/@smithy/util-hex-encoding@2.1.1/denonext/util-hex-encoding.mjs";import{toUint8Array as Ae}from"/v135/@smithy/util-utf8@2.1.1/denonext/util-utf8.mjs";var m=async({headers:o,body:e},t)=>{for(let r of Object.keys(o))if(r.toLowerCase()===l)return o[r];if(e==null)return"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";if(typeof e=="string"||ArrayBuffer.isView(e)||ce(e)){let r=new t;return r.update(Ae(e)),Ee(await r.digest())}return W};var ee=(o,e)=>{o=o.toLowerCase();for(let t of Object.keys(e))if(o===t.toLowerCase())return!0;return!1};var T=({headers:o,query:e,...t})=>({...t,headers:{...o},query:e?he(e):void 0}),he=o=>Object.keys(o).reduce((e,t)=>{let r=o[t];return{...e,[t]:Array.isArray(r)?[...r]:r}},{});var U=(o,e={})=>{let{headers:t,query:r={}}=typeof o.clone=="function"?o.clone():T(o);for(let s of Object.keys(t)){let n=s.toLowerCase();n.slice(0,6)==="x-amz-"&&!e.unhoistableHeaders?.has(n)&&(r[s]=t[s],delete t[s])}return{...o,headers:t,query:r}};var H=o=>{o=typeof o.clone=="function"?o.clone():T(o);for(let e of Object.keys(o.headers))j.indexOf(e.toLowerCase())>-1&&delete o.headers[e];return o};var te=o=>pe(o).toISOString().replace(/\.\d{3}Z$/,"Z"),pe=o=>typeof o=="number"?new Date(o*1e3):typeof o=="string"?Number(o)?new Date(Number(o)*1e3):new Date(o):o;var oe=class{constructor({applyChecksum:e,credentials:t,region:r,service:s,sha256:n,uriEscapePath:a=!0}){this.headerMarshaller=new de(ue,fe),this.service=s,this.sha256=n,this.uriEscapePath=a,this.applyChecksum=typeof e=="boolean"?e:!0,this.regionProvider=re(r),this.credentialProvider=re(t)}async presign(e,t={}){let{signingDate:r=new Date,expiresIn:s=3600,unsignableHeaders:n,unhoistableHeaders:a,signableHeaders:i,signingRegion:A,signingService:c}=t,h=await this.credentialProvider();this.validateResolvedCredentials(h);let d=A??await this.regionProvider(),{longDate:p,shortDate:f}=w(r);if(s>B)return Promise.reject("Signature version 4 presigned URLs must have an expiration date less than one week in the future");let u=y(f,d,c??this.service),E=U(H(e),{unhoistableHeaders:a});h.sessionToken&&(E.query[N]=h.sessionToken),E.query[Y]=g,E.query[b]=`${h.accessKeyId}/${u}`,E.query[I]=p,E.query[G]=s.toString(10);let O=D(E,n,i);return E.query[k]=se(O),E.query[P]=await this.getSignature(p,u,this.getSigningKey(h,d,f,c),this.createCanonicalRequest(E,O,await m(e,this.sha256))),E}async sign(e,t){return typeof e=="string"?this.signString(e,t):e.headers&&e.payload?this.signEvent(e,t):e.message?this.signMessage(e,t):this.signRequest(e,t)}async signEvent({headers:e,payload:t},{signingDate:r=new Date,priorSignature:s,signingRegion:n,signingService:a}){let i=n??await this.regionProvider(),{shortDate:A,longDate:c}=w(r),h=y(A,i,a??this.service),d=await m({headers:{},body:t},this.sha256),p=new this.sha256;p.update(e);let f=x(await p.digest()),u=[F,c,h,s,f,d].join(`
`);return this.signString(u,{signingDate:r,signingRegion:i,signingService:a})}async signMessage(e,{signingDate:t=new Date,signingRegion:r,signingService:s}){return this.signEvent({headers:this.headerMarshaller.format(e.message.headers),payload:e.message.body},{signingDate:t,signingRegion:r,signingService:s,priorSignature:e.priorSignature}).then(a=>({message:e.message,signature:a}))}async signString(e,{signingDate:t=new Date,signingRegion:r,signingService:s}={}){let n=await this.credentialProvider();this.validateResolvedCredentials(n);let a=r??await this.regionProvider(),{shortDate:i}=w(t),A=new this.sha256(await this.getSigningKey(n,a,i,s));return A.update(v(e)),x(await A.digest())}async signRequest(e,{signingDate:t=new Date,signableHeaders:r,unsignableHeaders:s,signingRegion:n,signingService:a}={}){let i=await this.credentialProvider();this.validateResolvedCredentials(i);let A=n??await this.regionProvider(),c=H(e),{longDate:h,shortDate:d}=w(t),p=y(d,A,a??this.service);c.headers[$]=h,i.sessionToken&&(c.headers[K]=i.sessionToken);let f=await m(c,this.sha256);!ee(l,c.headers)&&this.applyChecksum&&(c.headers[l]=f);let u=D(c,s,r),E=await this.getSignature(h,p,this.getSigningKey(i,A,d,a),this.createCanonicalRequest(c,u,f));return c.headers[C]=`${g} Credential=${i.accessKeyId}/${p}, SignedHeaders=${se(u)}, Signature=${E}`,c}createCanonicalRequest(e,t,r){let s=Object.keys(t).sort();return`${e.method}
${this.getCanonicalPath(e)}
${M(e)}
${s.map(n=>`${n}:${t[n]}`).join(`
`)}

${s.join(";")}
${r}`}async createStringToSign(e,t,r){let s=new this.sha256;s.update(v(r));let n=await s.digest();return`${g}
${e}
${t}
${x(n)}`}getCanonicalPath({path:e}){if(this.uriEscapePath){let t=[];for(let n of e.split("/"))n?.length!==0&&n!=="."&&(n===".."?t.pop():t.push(n));let r=`${e?.startsWith("/")?"/":""}${t.join("/")}${t.length>0&&e?.endsWith("/")?"/":""}`;return encodeURIComponent(r).replace(/%2F/g,"/")}return e}async getSignature(e,t,r,s){let n=await this.createStringToSign(e,t,s),a=new this.sha256(await r);return a.update(v(n)),x(await a.digest())}getSigningKey(e,t,r,s){return J(this.sha256,e,r,t,s||this.service)}validateResolvedCredentials(e){if(typeof e!="object"||typeof e.accessKeyId!="string"||typeof e.secretAccessKey!="string")throw new Error("Resolved credential object is not valid")}},w=o=>{let e=te(o).replace(/[\-:]/g,"");return{longDate:e,shortDate:e.slice(0,8)}},se=o=>Object.keys(o).sort().join(";");export{oe as SignatureV4,_e as clearCredentialCache,y as createScope,D as getCanonicalHeaders,M as getCanonicalQuery,m as getPayloadHash,J as getSigningKey,U as moveHeadersToQuery,H as prepareRequest};
//# sourceMappingURL=signature-v4.mjs.map