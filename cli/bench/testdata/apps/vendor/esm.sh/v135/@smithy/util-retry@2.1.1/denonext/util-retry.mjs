/* esm.sh - esbuild bundle(@smithy/util-retry@2.1.1) denonext production */
var i;(function(a){a.STANDARD="standard",a.ADAPTIVE="adaptive"})(i||(i={}));var u=3,_=i.STANDARD;import{isThrottlingError as A}from"/v135/@smithy/service-error-classification@2.1.1/denonext/service-error-classification.mjs";var c=class{constructor(t){this.currentCapacity=0,this.enabled=!1,this.lastMaxRate=0,this.measuredTxRate=0,this.requestCount=0,this.lastTimestamp=0,this.timeWindow=0,this.beta=t?.beta??.7,this.minCapacity=t?.minCapacity??1,this.minFillRate=t?.minFillRate??.5,this.scaleConstant=t?.scaleConstant??.4,this.smooth=t?.smooth??.8;let e=this.getCurrentTimeInSeconds();this.lastThrottleTime=e,this.lastTxRateBucket=Math.floor(this.getCurrentTimeInSeconds()),this.fillRate=this.minFillRate,this.maxCapacity=this.minCapacity}getCurrentTimeInSeconds(){return Date.now()/1e3}async getSendToken(){return this.acquireTokenBucket(1)}async acquireTokenBucket(t){if(this.enabled){if(this.refillTokenBucket(),t>this.currentCapacity){let e=(t-this.currentCapacity)/this.fillRate*1e3;await new Promise(r=>setTimeout(r,e))}this.currentCapacity=this.currentCapacity-t}}refillTokenBucket(){let t=this.getCurrentTimeInSeconds();if(!this.lastTimestamp){this.lastTimestamp=t;return}let e=(t-this.lastTimestamp)*this.fillRate;this.currentCapacity=Math.min(this.maxCapacity,this.currentCapacity+e),this.lastTimestamp=t}updateClientSendingRate(t){let e;if(this.updateMeasuredRate(),A(t)){let s=this.enabled?Math.min(this.measuredTxRate,this.fillRate):this.measuredTxRate;this.lastMaxRate=s,this.calculateTimeWindow(),this.lastThrottleTime=this.getCurrentTimeInSeconds(),e=this.cubicThrottle(s),this.enableTokenBucket()}else this.calculateTimeWindow(),e=this.cubicSuccess(this.getCurrentTimeInSeconds());let r=Math.min(e,2*this.measuredTxRate);this.updateTokenBucketRate(r)}calculateTimeWindow(){this.timeWindow=this.getPrecise(Math.pow(this.lastMaxRate*(1-this.beta)/this.scaleConstant,1/3))}cubicThrottle(t){return this.getPrecise(t*this.beta)}cubicSuccess(t){return this.getPrecise(this.scaleConstant*Math.pow(t-this.lastThrottleTime-this.timeWindow,3)+this.lastMaxRate)}enableTokenBucket(){this.enabled=!0}updateTokenBucketRate(t){this.refillTokenBucket(),this.fillRate=Math.max(t,this.minFillRate),this.maxCapacity=Math.max(t,this.minCapacity),this.currentCapacity=Math.min(this.currentCapacity,this.maxCapacity)}updateMeasuredRate(){let t=this.getCurrentTimeInSeconds(),e=Math.floor(t*2)/2;if(this.requestCount++,e>this.lastTxRateBucket){let r=this.requestCount/(e-this.lastTxRateBucket);this.measuredTxRate=this.getPrecise(r*this.smooth+this.measuredTxRate*(1-this.smooth)),this.requestCount=0,this.lastTxRateBucket=e}}getPrecise(t){return parseFloat(t.toFixed(8))}};var o=100,h=2e4,m=500,R=500,p=5,d=10,f=1,M="amz-sdk-invocation-id",B="amz-sdk-request";var E=()=>{let a=100;return{computeNextBackoffDelay:r=>Math.floor(Math.min(2e4,Math.random()*2**r*a)),setDelayBase:r=>{a=r}}};var y=({retryDelay:a,retryCount:t,retryCost:e})=>({getRetryCount:()=>t,getRetryDelay:()=>Math.min(2e4,a),getRetryCost:()=>e});var n=class{constructor(t){this.maxAttempts=t,this.mode=i.STANDARD,this.capacity=500,this.retryBackoffStrategy=E(),this.maxAttemptsProvider=typeof t=="function"?t:async()=>t}async acquireInitialRetryToken(t){return y({retryDelay:100,retryCount:0})}async refreshRetryTokenForRetry(t,e){let r=await this.getMaxAttempts();if(this.shouldRetry(t,e,r)){let s=e.errorType;this.retryBackoffStrategy.setDelayBase(s==="THROTTLING"?500:100);let T=this.retryBackoffStrategy.computeNextBackoffDelay(t.getRetryCount()),S=e.retryAfterHint?Math.max(e.retryAfterHint.getTime()-Date.now()||0,T):T,l=this.getCapacityCost(s);return this.capacity-=l,y({retryDelay:S,retryCount:t.getRetryCount()+1,retryCost:l})}throw new Error("No retry token available")}recordSuccess(t){this.capacity=Math.max(500,this.capacity+(t.getRetryCost()??1))}getCapacity(){return this.capacity}async getMaxAttempts(){try{return await this.maxAttemptsProvider()}catch{return console.warn(`Max attempts provider could not resolve. Using default of ${u}`),u}}shouldRetry(t,e,r){return t.getRetryCount()+1<r&&this.capacity>=this.getCapacityCost(e.errorType)&&this.isRetryableError(e.errorType)}getCapacityCost(t){return t==="TRANSIENT"?10:5}isRetryableError(t){return t==="THROTTLING"||t==="TRANSIENT"}};var C=class{constructor(t,e){this.maxAttemptsProvider=t,this.mode=i.ADAPTIVE;let{rateLimiter:r}=e??{};this.rateLimiter=r??new c,this.standardRetryStrategy=new n(t)}async acquireInitialRetryToken(t){return await this.rateLimiter.getSendToken(),this.standardRetryStrategy.acquireInitialRetryToken(t)}async refreshRetryTokenForRetry(t,e){return this.rateLimiter.updateClientSendingRate(e),this.standardRetryStrategy.refreshRetryTokenForRetry(t,e)}recordSuccess(t){this.rateLimiter.updateClientSendingRate({}),this.standardRetryStrategy.recordSuccess(t)}};var x=class extends n{constructor(t,e=100){super(typeof t=="function"?t:async()=>t),typeof e=="number"?this.computeNextBackoffDelay=()=>e:this.computeNextBackoffDelay=e}async refreshRetryTokenForRetry(t,e){let r=await super.refreshRetryTokenForRetry(t,e);return r.getRetryDelay=()=>this.computeNextBackoffDelay(r.getRetryCount()),r}};export{C as AdaptiveRetryStrategy,x as ConfiguredRetryStrategy,u as DEFAULT_MAX_ATTEMPTS,o as DEFAULT_RETRY_DELAY_BASE,_ as DEFAULT_RETRY_MODE,c as DefaultRateLimiter,R as INITIAL_RETRY_TOKENS,M as INVOCATION_ID_HEADER,h as MAXIMUM_RETRY_DELAY,f as NO_RETRY_INCREMENT,B as REQUEST_HEADER,p as RETRY_COST,i as RETRY_MODES,n as StandardRetryStrategy,m as THROTTLING_RETRY_DELAY_BASE,d as TIMEOUT_RETRY_COST};
//# sourceMappingURL=util-retry.mjs.map