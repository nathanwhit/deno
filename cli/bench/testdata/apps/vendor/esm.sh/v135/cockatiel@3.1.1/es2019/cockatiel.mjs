/* esm.sh - esbuild bundle(cockatiel@3.1.1) es2019 production */
import __Process$ from "/v135/node_process.js";
var d=class{constructor(t){this.interval=t}next(){return K(this.interval)}},K=e=>({duration:e,next(){return this}});var I=class{constructor(t){this.fn=t}next(t){return O(this.fn).next(t)}},O=(e,t,r=0)=>({duration:r,next(s){let i=e(s,t);return typeof i=="number"?O(e,t,i):O(e,i.state,i.delay)}});var j=(e=0,t)=>[Math.min(t.maxDelay,t.initialDelay*2**e),e+1],et=(e,t)=>{let[r,s]=j(e,t);return[Math.floor(Math.random()*r),s]},rt=(e,t)=>{let[r,s]=j(e,t);return[Math.floor((r+Math.random()*r)/2),s]};var Q=.7142857142857143,q=(e,t)=>{let[r,s]=e||[0,0],i=r+Math.random(),n=Math.pow(t.exponent,i)*Math.tanh(Math.sqrt(4*i)),a=Math.max(0,n-s);return[Math.min(a*Q*t.initialDelay,t.maxDelay),[r+1,n]]};var M={generator:q,maxDelay:3e4,exponent:2,initialDelay:128},P=class{constructor(t){this.options=t?{...M,...t}:M}next(){return D(this.options).next(void 0)}},D=(e,t,r=0,s=-1)=>({duration:r,next(){let[i,n]=e.generator(t,e);return D(e,n,i,s+1)}});var H=class{constructor(t){this.durations=t}next(){return B(this.durations,0)}},B=(e,t)=>({duration:e[t],next(){return t===e.length-1?this:B(e,t+1)}});var h=class extends Error{constructor(t="Operation cancelled"){super(t),this.message=t,this.isTaskCancelledError=!0}};var G={dispose:()=>{}},w;(function(e){e.once=(t,r)=>{let s=!1,i;return i=t(n=>{r(n),i?i.dispose():s=!0}),s?(i.dispose(),G):i},e.toPromise=(t,r)=>r?r.aborted?Promise.reject(new h):new Promise((s,i)=>{let n=E(r)(()=>{a.dispose(),i(new h)}),a=e.once(t,p=>{n.dispose(),s(p)})}):new Promise(s=>e.once(t,s))})(w||(w={}));var E=e=>{let t=new R;if(e.aborted)return t.emit(),t.addListener;let r=()=>{t.emit(),e.removeEventListener("abort",r)};return e.addEventListener("abort",r),t.addListener},u=class{constructor(){this.addListener=t=>this.addListenerInner(t)}get size(){return this.listeners?typeof this.listeners=="function"?1:this.listeners.length:0}emit(t){if(this.listeners)if(typeof this.listeners=="function")this.listeners(t);else for(let r of this.listeners)r(t)}addListenerInner(t){return this.listeners?typeof this.listeners=="function"?this.listeners=[this.listeners,t]:this.listeners.push(t):this.listeners=t,{dispose:()=>this.removeListener(t)}}removeListener(t){if(!this.listeners)return;if(typeof this.listeners=="function"){this.listeners===t&&(this.listeners=void 0);return}let r=this.listeners.indexOf(t);r!==-1&&(this.listeners.length===2?this.listeners=r===0?this.listeners[1]:this.listeners[0]:this.listeners=this.listeners.slice(0,r).concat(this.listeners.slice(r+1)))}};var R=class extends u{constructor(){super(...arguments),this.addListener=t=>this.lastValue?(t(this.lastValue.value),G):this.addListenerInner(t)}emit(t){this.lastValue={value:t},super.emit(t),this.listeners=void 0}};var l=new AbortController().signal,V=new AbortController;V.abort();var lt=V.signal,U=e=>{let t=new AbortController;if(!e)return t;if(e.aborted&&t.abort(),e!==l){let r=new WeakRef(t);E(e)(()=>{var s;return(s=r.deref())==null?void 0:s.abort()})}return t};var f=e=>{if("error"in e)throw e.error;return"success"in e?e.success:e.value},X=()=>{if(typeof performance!="undefined"){let e=performance.now();return()=>performance.now()-e}else{let e=__Process$.hrtime.bigint();return()=>Number(__Process$.hrtime.bigint()-e)/1e6}},c=class e{constructor(t=()=>!1,r=()=>!1){this.errorFilter=t,this.resultFilter=r,this.successEmitter=new u,this.failureEmitter=new u,this.onSuccess=this.successEmitter.addListener,this.onFailure=this.failureEmitter.addListener}clone(){return new e(this.errorFilter,this.resultFilter)}async invoke(t,...r){let s=this.successEmitter.size||this.failureEmitter.size?X():null;try{let i=await t(...r);return this.resultFilter(i)?(s&&this.failureEmitter.emit({duration:s(),handled:!0,reason:{value:i}}),{value:i}):(s&&this.successEmitter.emit({duration:s()}),{success:i})}catch(i){let n=i,a=this.errorFilter(n);if(s&&this.failureEmitter.emit({duration:s(),handled:a,reason:{error:n}}),!a)throw n;return{error:n}}}};var x=class extends Error{constructor(t="Execution prevented because the circuit breaker is open"){super(t),this.isBrokenCircuitError=!0}};var y=class extends Error{constructor(t,r){super(`Bulkhead capacity exceeded (0/${t} execution slots, 0/${r} available)`),this.isBulkheadRejectedError=!0}};var b=class extends x{constructor(){super("Execution prevented because the circuit breaker is open"),this.isIsolatedCircuitError=!0}};var vt=e=>!!e&&e instanceof Error&&"isBrokenCircuitError"in e,yt=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e,bt=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e,Ft=e=>!!e&&e instanceof Error&&"isBulkheadRejectedError"in e;var o;(function(e){e[e.Closed=0]="Closed",e[e.Open=1]="Open",e[e.HalfOpen=2]="HalfOpen",e[e.Isolated=3]="Isolated"})(o||(o={}));var F=class{constructor(t,r){this.options=t,this.executor=r,this.breakEmitter=new u,this.resetEmitter=new u,this.halfOpenEmitter=new u,this.stateChangeEmitter=new u,this.innerState={value:o.Closed},this.onBreak=this.breakEmitter.addListener,this.onReset=this.resetEmitter.addListener,this.onHalfOpen=this.halfOpenEmitter.addListener,this.onStateChange=this.stateChangeEmitter.addListener,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}get state(){return this.innerState.value}get lastFailure(){return this.innerLastFailure}isolate(){this.innerState.value!==o.Isolated&&(this.innerState={value:o.Isolated,counters:0},this.breakEmitter.emit({isolated:!0}),this.stateChangeEmitter.emit(o.Isolated)),this.innerState.counters++;let t=!1;return{dispose:()=>{t||(t=!0,this.innerState.value===o.Isolated&&!--this.innerState.counters&&(this.innerState={value:o.Closed},this.resetEmitter.emit(),this.stateChangeEmitter.emit(o.Closed)))}}}async execute(t,r=l){let s=this.innerState;switch(s.value){case o.Closed:let i=await this.executor.invoke(t,{signal:r});return"success"in i?this.options.breaker.success(s.value):(this.innerLastFailure=i,this.options.breaker.failure(s.value)&&this.open(i)),f(i);case o.HalfOpen:if(await s.test.catch(()=>{}),this.state===o.Closed&&r.aborted)throw new h;return this.execute(t);case o.Open:if(Date.now()-s.openedAt<this.options.halfOpenAfter)throw new x;let n=this.halfOpen(t,r);return this.innerState={value:o.HalfOpen,test:n},this.stateChangeEmitter.emit(o.HalfOpen),n;case o.Isolated:throw new b;default:throw new Error(`Unexpected circuit state ${s}`)}}async halfOpen(t,r){this.halfOpenEmitter.emit();try{let s=await this.executor.invoke(t,{signal:r});return"success"in s?(this.options.breaker.success(o.HalfOpen),this.close()):(this.innerLastFailure=s,this.options.breaker.failure(o.HalfOpen),this.open(s)),f(s)}catch(s){throw this.close(),s}}open(t){this.state===o.Isolated||this.state===o.Open||(this.innerState={value:o.Open,openedAt:Date.now()},this.breakEmitter.emit(t),this.stateChangeEmitter.emit(o.Open))}close(){this.state===o.HalfOpen&&(this.innerState={value:o.Closed},this.resetEmitter.emit(),this.stateChangeEmitter.emit(o.Closed))}};var $=class{constructor({threshold:t,duration:r,minimumRps:s}){if(this.windows=[],this.currentWindow=0,this.currentFailures=0,this.currentSuccesses=0,t<=0||t>=1)throw new RangeError(`SamplingBreaker threshold should be between (0, 1), got ${t}`);this.threshold=t;let i=Math.max(5,Math.ceil(r/1e3));for(let n=0;n<i;n++)this.windows.push({startedAt:0,failures:0,successes:0});this.windowSize=Math.round(r/i),this.duration=this.windowSize*i,s?this.minimumRpms=s/1e3:this.minimumRpms=5/(t*1e3)}success(t){t===o.HalfOpen&&this.resetWindows(),this.push(!0)}failure(t){if(this.push(!1),t!==o.Closed)return!0;let r=this.currentSuccesses+this.currentFailures;return r<this.duration*this.minimumRpms?!1:this.currentFailures>this.threshold*r}resetWindows(){this.currentFailures=0,this.currentSuccesses=0;for(let t of this.windows)t.failures=0,t.successes=0,t.startedAt=0}rotateWindow(t){let r=(this.currentWindow+1)%this.windows.length;this.currentFailures-=this.windows[r].failures,this.currentSuccesses-=this.windows[r].successes;let s=this.windows[r]={failures:0,successes:0,startedAt:t};return this.currentWindow=r,s}push(t){let r=Date.now(),s=this.windows[this.currentWindow];r-s.startedAt>=this.windowSize&&(s=this.rotateWindow(r)),t?(s.successes++,this.currentSuccesses++):(s.failures++,this.currentFailures++)}};var z=class{constructor(t){this.threshold=t,this.count=0}success(){this.count=0}failure(){return++this.count>=this.threshold}};var J=()=>{let e,t,r=new Promise((s,i)=>{e=s,t=i});return{resolve:e,reject:t,promise:r}};var S=class{constructor(t,r){this.capacity=t,this.queueCapacity=r,this.active=0,this.queue=[],this.onRejectEmitter=new u,this.executor=new c,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure,this.onReject=this.onRejectEmitter.addListener}get executionSlots(){return this.capacity-this.active}get queueSlots(){return this.queueCapacity-this.queue.length}async execute(t,r=l){if(r.aborted)throw new h;if(this.active<this.capacity){this.active++;try{return await t({signal:r})}finally{this.active--,this.dequeue()}}if(this.queue.length<this.queueCapacity){let{resolve:s,reject:i,promise:n}=J();return this.queue.push({signal:r,fn:t,resolve:s,reject:i}),n}throw this.onRejectEmitter.emit(),new y(this.capacity,this.queueCapacity)}dequeue(){let t=this.queue.shift();t&&Promise.resolve().then(()=>this.execute(t.fn,t.signal)).then(t.resolve).catch(t.reject)}};var k=class{constructor(t,r){this.executor=t,this.value=r,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}async execute(t,r=l){let s=await this.executor.invoke(t,{signal:r});return"success"in s?s.success:this.value()}};var g=class{constructor(){this.executor=new c,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure}async execute(t,r=l){return f(await this.executor.invoke(t,{signal:r}))}};var Y=(e,t)=>new Promise(r=>{let s=setTimeout(r,e);t&&s.unref()}),C=class e{constructor(t,r){this.options=t,this.executor=r,this.onGiveUpEmitter=new u,this.onRetryEmitter=new u,this.onSuccess=this.executor.onSuccess,this.onFailure=this.executor.onFailure,this.onRetry=this.onRetryEmitter.addListener,this.onGiveUp=this.onGiveUpEmitter.addListener}dangerouslyUnref(){return new e({...this.options,unref:!0},this.executor.clone())}async execute(t,r=l){let s=this.options.backoff||new d(0),i;for(let n=0;;n++){let a=await this.executor.invoke(t,{attempt:n,signal:r});if("success"in a)return a.success;if(!r.aborted&&n<this.options.maxAttempts){let p={attempt:n+1,signal:r,result:a};i=i?i.next(p):s.next(p);let W=i.duration,N=Y(W,!!this.options.unref);this.onRetryEmitter.emit({...a,delay:W}),await N;continue}if(this.onGiveUpEmitter.emit(a),"error"in a)throw a.error;return a.value}}};var T;(function(e){e.Cooperative="optimistic",e.Aggressive="aggressive"})(T||(T={}));var A=class e{constructor(t,r,s=new c,i=!1){this.duration=t,this.options=r,this.executor=s,this.unref=i,this.timeoutEmitter=new u,this.onTimeout=this.timeoutEmitter.addListener,this.onFailure=this.executor.onFailure,this.onSuccess=this.executor.onSuccess}dangerouslyUnref(){return new e(this.duration,this.options,this.executor,!0)}async execute(t,r){let s=U(r),i=setTimeout(()=>s.abort(),this.duration);this.unref&&i.unref();let n={signal:s.signal},a=E(s.signal),p=a(()=>this.timeoutEmitter.emit());try{return this.options.strategy===T.Cooperative?f(await this.executor.invoke(t,n,s.signal)):await this.executor.invoke(async()=>Promise.race([Promise.resolve(t(n,s.signal)),w.toPromise(a).then(()=>{throw new h(`Operation timed out after ${this.duration}ms`)})])).then(f)}finally{p.dispose(),this.options.abortOnReturn!==!1&&s.abort(),clearTimeout(i)}}};var L=(e,t)=>t?r=>r instanceof e&&t(r):r=>r instanceof e,Z=()=>!0,v=()=>!1,m=class e{constructor(t){this.options=t}orType(t,r){let s=L(t,r);return new e({...this.options,errorFilter:i=>this.options.errorFilter(i)||s(i)})}orWhen(t){return new e({...this.options,errorFilter:r=>this.options.errorFilter(r)||t(r)})}orWhenResult(t){return new e({...this.options,resultFilter:r=>this.options.resultFilter(r)||t(r)})}orResultType(t,r){let s=L(t,r);return new e({...this.options,resultFilter:i=>this.options.resultFilter(i)||s(i)})}},fe=new g,me=new m({errorFilter:Z,resultFilter:v});function de(e,t){return new m({errorFilter:L(e,t),resultFilter:v})}function xe(e){return new m({errorFilter:e,resultFilter:v})}function we(e,t){return new m({errorFilter:v,resultFilter:L(e,t)})}function Ee(e){return new m({errorFilter:v,resultFilter:e})}function ve(e,t=0){return new S(e,t)}function ye(e){return(t,r,s)=>{let i=s.value;if(typeof i!="function")throw new Error(`Can only decorate functions with @cockatiel, got ${typeof i}`);s.value=function(...n){let a=n[n.length-1]instanceof AbortSignal?n.pop():void 0;return e.execute(p=>i.apply(this,[...n,p]),a)}}}function be(e,t){return new A(e,typeof t=="string"?{strategy:t}:t)}function Fe(...e){return{_altReturn:void 0,onFailure:e[0].onFailure,onSuccess:e[0].onSuccess,wrapped:e,execute(t,r){let s=(i,n)=>n===e.length?t(i):e[n].execute(a=>s({...i,...a},n+1),i.signal);return Promise.resolve(s({signal:r},0))}}}function Se(e,t){var r;return new C({backoff:t.backoff||new d(0),maxAttempts:(r=t.maxAttempts)!=null?r:1/0},new c(e.options.errorFilter,e.options.resultFilter))}function ke(e,t){return new F(t,new c(e.options.errorFilter,e.options.resultFilter))}function ge(e,t){return new k(new c(e.options.errorFilter,e.options.resultFilter),typeof t=="function"?t:()=>t)}export{x as BrokenCircuitError,S as BulkheadPolicy,y as BulkheadRejectedError,F as CircuitBreakerPolicy,o as CircuitState,z as ConsecutiveBreaker,d as ConstantBackoff,I as DelegateBackoff,w as Event,u as EventEmitter,P as ExponentialBackoff,k as FallbackPolicy,b as IsolatedCircuitError,H as IterableBackoff,g as NoopPolicy,m as Policy,C as RetryPolicy,$ as SamplingBreaker,h as TaskCancelledError,A as TimeoutPolicy,T as TimeoutStrategy,ve as bulkhead,ke as circuitBreaker,q as decorrelatedJitterGenerator,ge as fallback,et as fullJitterGenerator,rt as halfJitterGenerator,me as handleAll,we as handleResultType,de as handleType,xe as handleWhen,Ee as handleWhenResult,vt as isBrokenCircuitError,yt as isBulkheadRejectedError,bt as isIsolatedCircuitError,Ft as isTaskCancelledError,j as noJitterGenerator,fe as noop,Se as retry,be as timeout,ye as usePolicy,Fe as wrap};
//# sourceMappingURL=cockatiel.mjs.map